<!doctype html>
<html lang="en" data-framework="jquery">
<head>
  <meta charset="utf-8">
<style>
body {font-family:Helvetica,Arial,sans-serif;font-size:1.25rem; margin: 10px 10px 10px 20px; line-height:1.5;}
h1 {font-size:1.75rem; color:#27A;}
h2 {font-size:1.5rem;}
p.hangl-li {margin-left:8px;}
pre {margin: 2px 4px 2px 8px; border:solid thin blue; padding:4px 4px 4px 8px; overflow:auto; line-height:1.2}
</style>
</head>
<body>
<h1>Getting Started</h1>
<p>This document describes the Tags framework at a conceptual level and describes
   how to use the features of the framework. See the 
   <a href='jsdocs/index.html'>API</a> document
   for programming details.</p>
<h2>Concepts</h2>
<p>HTML, which is more or less XML, provides a good paradigm for describing the 
   structural and visual aspects of a Web application while 
   Javascript, which is a pretty good OOP language is good at describing the semantics. 
   What is missing, is a good way to tie the two components together.</p>
<p>We would like to be able to use XML in a more general way to describe program components
   and then automatically link these components to Javascript code that can provide the
   implementation details to render and activate these generalized components.</p>
<p>The Tags framework does this by providing a way to extend HTML with custom tags backed up with Javascript.
   The XML tag name selects an implementing Javascript Class. XML attributes map to Javascript object
   attributes. Nested XML content, which can be standard HTML or other custom tags,
   is represented in the implementing Javascript object instance as the 'content' array attribute.</p>
<p>The Tags framework lets the programmer structure the application as if HTML implemented
   what ever tags he finds convenient and then use Javascript to make it so.</p>
   
<h2>Handling Objects</h2>
<p>Tags provides a Class mechanism to define Tag object types using the define() method
   and instantiate Tag objects using the create() method. 
   It is based on <a href='http://ejohn.org/blog/simple-javascript-inheritance/'>Class.js</a> which
   implements class inheritance. Tag objects mimic XML semantics and have a 'tag' attribute
   that indicates the type of the object and an optional 'content' tag which contains
   nested content of a Tag object.</p>
   
<p>The create() method takes a single input parameter which specifies an XML or Javascript
   structure which is to be turned into a Tag object. XML can be provided as an XML-Node
   object or as a string that starts with a '&lt;' character. It is the 'tag' attribute
   of the XML or Javascript object literal which selects the Javascript Class to be
   used to instantiate the object. The create() method
   operates recursively on nested XML content or, in the case of Javascript, nested
   content provided in the 'content' attribute.</p>
   
<p>Here is an example of a Tag object that contains information about a Person
   and knows how to serialize and save itself in local storage.</p>
   
<p>To define the Tag object 'person' type ...</p>

<pre>
    Tags.define({
      tag:'person',
      
      save: function() {
        var rep = JSON.stringify(this.serialize());
        localStorage.setItem('myNamespace-'+this.lastName+'-',rep);
      },
                 
      serialize: function() {
        return {firstName:this.firstName,
                lastName:this.lastName,
                address:this.address,
                gender:this.gender};
               }
        });
      }
    });
</pre>

<p>To instantiate a 'person' Tag object ...</p>

<pre>
  ...
  var person = Tags.create({tag:'person',firstName:'John',lastName:'Doe',
                            gender:'M',
                            address:'1234 Maple St., Irvine CA 92714'});
</pre>

<p>--- Or ---</p>

<pre>
  ...  
  var person = Tags.create("&lt;person firstName='John' lastName='Doe'"
                                 +" gender='M'"
                                 +" address='1234 Maple St., Irvine CA 92714' /&gt;");
</pre>

<p>Then to save it to localStorage ...</</p>

<pre>
  ...
  person.save();
</pre>

<p>And to restore it from localStorage ...</p>

<pre>
  ...
  var person = Tags.create(JSON.parse(localStorage.getItem('myNamespace-Doe-John'));
</pre>

<h2>Handling Views</h2>
<p>The Tags framework defines a built-in Class called View. The key methods of the View class 
   are its render() and activate() methods.</p>
<ul>  
  <li>view.render - Render the object as XML (or HTML) and return it as a jQuery DOM element</li>
  <li>view.activate - Attach event handlers and do other DOM related activities</li>
</ul>       

<p>What makes the View class useful is that any unrecognized tag name is bound to the View Class
   which knows how to render standard HTML tags.
   This lets you create View structures that represent arbitrary HTML and can be used
   to render and manipulate HTML DOM objects. It means that custom tags can contain
   standard HTML as content and vice versa.</p> 

<p>Using a View object requires a sequence of operations that includes instantiate,
   render, attach to the DOM and activate. Here is how that would work for
   a simple "Hello World" case using jQuery.</p>
   
<pre>
var view = Tags.create({tag:'div', content:'Hello World'});  // Instantiate
$(document).append(view.render());  // Render and attach to the DOM
view.activate(); // Activate
</pre>

<p>A View object can be attached to static HTML in which case the 
   the render and attach steps are not used. In this case, 
   set the 'el' attribute to a CSS selector or set the 'id' attribute
   to the 'id' attribute of the static HTML element. The default
   activate() method checks for the presence of the '$el' attribute
   (which would normally be set by the render() method if it were
   used) and if not there, it will use the 'el' attribute or the 'id'
   attribute to find the DOM element and set the '$el' attribute.</p>
   
<p>You have the full power of
   Javascript to use to create the input to the Tags.create() method.
   You can specify event handlers and instance-specific methods
   in the configuration object passed to Tags.create().</p>

<h2>Custom Tags</h2>

<p>The next step is to define your own custom tags. Simply define your render() and activate() 
   methods as needed and you can place your custom tag anywhere a normal HTML tag would go. 
   In practice, we override the renderText() method rather than the render() method. Here 
   is a Hello World example ...</p>
   
<pre>
Tags.define({  
  tag:'hello',
  extend:'view',
  renderText:function() {
    if (this.message) this.content = this.message;
    return this.renderAs('span');
  }
});
</pre>

<p>Use the tag in the body of your HTML file ...</p>
<pre>
...
&lt;body&gt;
  &lt;script type='text/custom-tags'&gt;
    &lt;hello message='Hello World'/&gt;
    &lt;hello&gt;Hello Again&lt;/hello&gt;
  &lt;/script&gt;
&lt;/body&gt;
...
</pre>

<p>The instantiate, render, attach and activate sequence is done automatically
   by the Tags framework in the case of HTML contained within &lt;script&gt; tags
   with a type of 'text/custom-tags'. The rendered HTML tag will be inserted into
   the DOM at a position just after the &lt;script&gt; tag. This feature lets you
   use custom tags just as you use standard HTML tags.</p>
   
<p>If you do not want this automatic behavior, just give the &lt;script&gt; some
   other type than 'text/custom-tag'.</p>

<p>One nice thing about the Tags framework is that custom tags are light-weight 
   and easy to define. This means you can create a custom tag just to bind an event 
   handler. Say you had an &lt;input&gt; tag to Start an operation and you wanted 
   to bind it to an event handler.  You could do this easily with jQuery, but there 
   is nothing in the &lt;input&gt; tag itself to indicate this. 
   And you need a way for jQuery to find the &lt;input&gt; tab. And the code to
   attach the event handler has to go somewhere. And you have to make sure it gets called.
   So there are lots of 
   things that can go wrong with a simple operation.</p>

<p>Alternatively, you could create a custom tag called 'startInput' which gives you 
   a place to put the event handler. You can look at the HTML and know from the
   custom tag name that there is Javascript code associated with it. 
   No ID is required and it does not matter where the Javascript code goes. Here 
   is the 'startInput' definition ...</p>
   
<pre>
Tags.define({
  tag:'startInput',
  extend:'view',
  htmlTag:'input',
  
  activate: function() {
    this._super();
    this.el.on('click',function() {
      alert('STARTED');
    });
  }
});
</pre>

<h3>Details</h3>
<p>There are a few implied behaviors to be covered.</p>
<ul>
  <li>You can get away without coding the renderText() method if your custom tag renders just like an HTML tag. In this case, you indicate the tag name to use as the attribute 'htmlTag' and rely on the default renderText() method.</li>
  <li>You can invoke an overridden method using the syntax "this._super()". This is part of the Class.js implementation.</li>
  <li>By convention, jQuery DOM elements start with '$'. this.$el is the only one used in the core module.
  <li>The activate() method of the View Class makes sure this.$el is set. It is normally set by the render() method, but if not, and the object has an 'id' attribute, then it is assumed that the 'id' matches the HTML tag and is used to select the HTML tag.</li>
</ul>

<h2>Widget Library</h2>

<p>The Tags framework provides the infrastructure for a comprehensive, general
   purpose Widget library. But being a new project, such is not yet available. We 
   have provided, however, a minimal library of layout widgets called
   <a href='jsdocs/module-boxlib.html'>boxlib</a> to show the
   way.</p>
   
<p>The Box Layout Library provides a partial solution to the HTML problem of how
   to layout components vertically and horizontally to completely fill
   a region such that the contents of the region gracefully expand and
   contract as the region is resized. It does not provide a completely 
   general solution, but works within the constraint that all components
   within the horizontal or vertical layout region are FIXED size
   except for, at most one component which is designated as the FLEX
   component. It further requires that the container must have a specified
   size, though that size can be a percentage.</p>
   
<h2>Conclusion</h2>

<p>Putting it all together, the Tags framework provides a general
   mechanism for linking XML structural semantics with Javascript
   procedural semantics and applies that to the specific problem
   of generating and controlling HTML and its corresponding DOM
   representation.</p>
   
<p>This general capability leads to better and more straight forward
   handling of both static and dynamic HTML. It provides a natural
   way to define and use custom tags that are either application
   specific or part of a general purpose Widget library.</p>
   
</body>
</html>
